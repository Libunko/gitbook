# 同步原语

## 为什么需要同步？

单 CPU 频率受功耗墙限制，多 CPU 发展迅速，多 CPU 多任务也意味着对共享资源的并发访问，为了保证访问共享资源的正确性，需要对可能同时访问共享资源的任务之间进行同步。

## 互斥锁（忙等）

- 作用：保护临界区

- 硬件实现：

  - 单核：关闭中断，关闭中断意味着当前执行的线程不能被其他线程抢占
  - 多核：关闭中断方法不再适用，即使关闭了所以核心的中断，也不能阻塞其他核心上正在执行的线程继续执行

- 软件实现：

  - 皮特森算法

- 软硬件协同：

  - 原子操作：原子操作指的是不可被打断的一个或一系列操作，常见的原子操作：

    - 比较和置换（Compare-And-Swap，CAS）
    - 拿取并累加（Fetch-And-Add，FAA）

  - 互斥锁抽象

    - 利用原子 CAS 实现的自旋锁（spinlock）

      自旋锁不具有公平性，即不能保证有限等待（忙等），从自旋锁的实现可以看出，自旋锁并非按照申请的顺序决定下一个获取锁的竞争者，在小大核环境下，小核运行频率低，与大核竞争时完成原子操作的概率远远小于大核。

    - 利用原子 FAA 实现的排号自旋锁

      排号自旋锁维护了一个先进先出（FIFO）的等待队列。

## 条件变量

自旋锁在拿不到锁的时候忙等待，浪费 CPU 资源，因此设计了条件变量的挂起/唤醒机制来解决这个问题。

互斥锁解决临界区问题，保证互斥访问共享资源，而条件变量通过提供挂起/唤醒机制来避免忙等待，节省 CPU 资源。条件变量需要和互斥锁搭配使用。

### 条件变量为什么要和互斥锁配合使用？

https://www.zhihu.com/question/24116967

https://stackoverflow.com/questions/4544234/calling-pthread-cond-signal-without-locking-mutex



## 信号量

信号量是由条件变量、互斥锁以及计数器实现的，而这个计数器是信号量的核心，用于表示当前可用资源的数量。因此可以理解为，信号量是利用条件变量实现了更高层级的抽象。





















## 原子操作（atomic）

所谓原子操作，就是该操作绝不会在执行完毕前被任何其他任务或事件打断，也就说，它是最小的执行单位，不可能有比它更小的执行单位。且原子操作实现与硬件架构强相关。

## 自旋锁（spinlock）

自旋锁在没有拿到锁时，忙等锁释放，从自旋锁的实现可以看出，自旋锁并非按照申请的顺序决定下一个获取锁的竞争者，在小大核环境下，小核运行频率低，与大核竞争时完成原子操作的概率远远小于大核，因此自旋锁不具有公平性。

## 排号自旋锁

