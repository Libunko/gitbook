# 进程间通信
进程间通信（Inter-Process Communication，IPC）
设计重心：接口的易用性、稳定性

## 管道（pipe）

例如查看当前进程是否有关键字为 target 相关的进程正在运行

```
ps aux | grep target
```

管道是单向的 IPC，内核通常有一定的缓冲区来缓冲消息，而进程的数据（消息抽象）是字节流。

管道通常有两种分类，主要区别是创建方式不同：

- 命名管道

  - 创建方式：是由 mkfifo 来创建的，在创建的时候会指定一个全局的文件名，由这个文件名来指代一个具体的管道（即管道名）

- 匿名管道

  - 创建方式：

    是通过 pipe 的系统调用创建的，在创建的同时进程会拿到读写的端口（两个文件描述符），因此匿名管道通常结合 fork ，即继承的方式完成一次权限的分发
  
  - 适用场合：关系比较近的进程

## System V 消息队列

发送和接收的接口是由操作系统内核提供的，支持同时存在多个发送者和多个接收者。

- 为什么需要消息队列？

  消息队列是唯一一个以消息为数据抽象的通信方式

- 基本操作

  - msgget：允许进程获取已有消息队列的连接或者创建一个新的消息队列

  - msgctl：可以控制和管理一个消息队列，如修改消息队列的权限信息或删除消息队列

  - msgsnd：发送消息

  - msgrcv：接收消

    只要队列有空闲的空间就可以向其发送消息，而接收者只要有未读消息就可以直接读取消息并完成操作。而如果发送消息时消息队列没有可用空间或者接收消息时没有未读消息，默认的操作是阻塞进程，msgsnd 或者 msgrcv 可直接指定是否阻塞（NOWAIT 选项）

- Linux 内核实现：

  - 消息队列的内存空间是有限制的，可配置
  - 消息队列在用户态和内核态之间传递时，会有拷贝的开销，会调用 copy_from_user 或者 copy_to_user
  - 建议在传递长消息时，使用共享内存机制而非消息队列

## System V 信号量

- 为什么需要信号量？

  和消息队列明确的传递消息的目的不同，信号量在实际的使用中主要是用作进程间的同步。

  信号量本身传递数据量一般很少，一般来说仅有一个共享的整形计数器，该计数器通常由内核维护，对信号量的操作需要经过内核系统调用。

- 信号量的主要操作时两个原语：

  - P：Probeer（尝试），表示尝试一个操作（将一个计数器减 1），该操作的失败会将当前进程切换到阻塞的状态，直到其他进程执行了 V 操作
  - V：Verhoog（增加），将一个计数器加 1，V 可能会唤醒一个因 P 操作而陷入阻塞的进程

## System V 共享内存

- 为什么需要共享内存？

  内核为管道、消息队列、信号量等提供了一系列进程间通信的接口，虽然这些完善的抽象方便了用户进程的使用，但是其中涉及的数据拷贝和控制流转移等处理逻辑影响了这些抽象的性能，而共享内存在内核为需要通信的进程建立了共享区域之后，内核基本就不需要参与进程间通信了。

- 共享内存允许一个或多个进程在其所在进程空间中映射相同的物理内存页

## 信号

- 为什么需要信号？

  管道、消息队列、共享内存等方式主要是关注在数据传输设计上，而信号的一个特点是其单向的事件通知能力。信号量也有通知能力，但需要进程主动去查询计数器状态或陷入阻塞状态（等待通知）。而使用进程可以随时发送一个事件到特定的进程、线程和进程组，并且接收事件的进程不需要阻塞等待该事件。

- 信号基本介绍：传递的消息很短，只有一个消息编号

- 信号的发送：用户态进程或内核

- 信号的阻塞/屏蔽：

  - linux 提供了一个专门用来允许用户程序设置对特定信号阻塞状态的函数 sigprocmask
  - 当一个信号被阻塞后，linux 将不会触发这个信号对应的处理函数，直到该信号被解除阻塞状态
  - 信号阻塞并不阻止信号被添加到等待队列上，而当进程解除对某个信号阻塞时，其可能需要处理在阻塞期间收到的信号
  - 很多重要的信号不能被阻塞，如 SIGKILL

- 信号的响应和处理

  - 处理的时机：通常是内核执行完异常、中断、系统调用等返回用户态的时刻，如 ret_to_user 是 linux 从内核返回到用户态的函数，此时，内核会检查一个状态位来判断是否由信号需要处理，如果有，则去处理该信号事件

  - 内核对信号一般有三种处理方式：

    - 忽略：直接忽略对应的信号
    - 用户处理函数：调用用户注册的信号处理函数
    - 内核默认处理函数：如果用户没有注册处理函数，则会调用内核默认的内核处理函数

  - linux 内核提供了 signal、sigaction 等系统调用允许用户为特定的信号注册一个用户态处理函数

  - 一个典型的处理过程：

    首先，一个用户态进程调用系统调用，进入了内核，内核在处理完系统调用后，发现有信号需要处理，于是切换到用户态处理信号处理函数，信号处理完成后，信号处理函数会通过系统调用 sigreturn 返回到内核。但是这里有个问题，linux 内核从内核态返回到用户态时，这一次系统调用相关的栈状态和上下文都被清空了，这就意味着如果不进行特殊的处理，即使信号处理函数调用 sigreturn 进入内核，内核再也不知道怎么恢复到此前的用户态上下文了。为了解决这个问题，在跳转到信号处理函数前，linux 会将系统调用的返回值和此前用户的上下文信息等保存在用户栈上，这样当内核接收到 sigreturn 的系统调用时，就会从用户栈上提取出这些上下文，然后恢复到之前的位置。

  - 信号处理函数的可重入考虑：

    在信号处理函数的执行过程中可能会触发嵌套信号，信号处理的嵌套可能导致最终指向结果和预期执行结果不一致，甚至导致更严重的问题，如在信号处理函数中使用全局锁保护一段关键操作时，可能会触发死锁问题。当信号处理函数第一次被调用，并拿到全局锁时，该信号可能再次被触发，并再次进入该信号处理函数，由于处理函数在第一次调用是获得了全局锁并且还没释放，在第二次调用时无法再次获得该锁，这回导致整个程序被阻塞，因此要考虑信号处理函数的可重入。

  - 可重入函数：允许多个任务并发使用，而不必担心数据错误，实现可重入函数需要注意以下几点：

    - 不使用静态数据，或者静态数据对信号处理函数都是只读的
    - 尽量只使用本地数据
    - 在必须使用全局共享数据的情况下，需要保护对全局数据的访问（需要避免前面介绍的死锁的发生）
    - 不调用不可重入的函数，很多常见的库函数实现（如 malloc）都是不可重入的，需要避免

## 套接字

- 为什么需要套接字通信？

  套接字（socket）是一种即可用于本地，又可跨网络使用的通信机制。

## 多种进程间通信机制对比

| IPC 机制 | 数据抽象 | 参与者   | 方向 | 内核实现                       |
| :------: | :------: | :------: | :--: | :-----------------: |
| 管道     | 字节流   | 两个进程 | 单向 | 通常以 FIFO 的缓冲区来管理数据。有匿名管道和命名管道两种实现 |
| 消息队列 | 消息 | 多进程 | 单向、双向 | 队列的组织方式，通过文件的权限来管理对队列的访问 |
| 信号量 | 计数器 | 多进程 | 单向、双向 | 内核维护共享计数器，通过文件的权限来管理对计数器的访问 |
| 共享内存 | 内存区间 | 多进程 | 单向、双向 | 内核维护共享的内存区域，通过文件的权限来管理对共享内存的访问 |
| 信号 | 事件编号 | 多进程 | 单向 | 为线程/进程维护信号等待队列，通过用户/组的权限来管理信号 |
| 套接字 | 数据报文 | 两个进程 | 单向、双向 | 有基于 IP/PORT 和基于文件路径的寻址方式，通过网络协议栈来管理通信 |

## 参考资料

1. 现代操作系统原理及实现-陈海波/夏虞斌